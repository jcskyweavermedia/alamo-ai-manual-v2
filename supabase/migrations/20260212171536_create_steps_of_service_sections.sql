-- =============================================================================
-- MIGRATION: create_steps_of_service_sections
-- Creates: table, constraints, indexes, FTS trigger, RRF search function,
--          CHECK constraint updates, RLS policies
-- Phase 1 of Steps of Service Viewer
-- =============================================================================


-- =============================================================================
-- STEP 1: CREATE TABLE
-- =============================================================================

CREATE TABLE public.steps_of_service_sections (
  id              UUID PRIMARY KEY DEFAULT extensions.gen_random_uuid(),

  -- Multi-tenant + position scoping
  group_id        UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  position        TEXT NOT NULL,

  -- Hierarchy
  section_key     TEXT NOT NULL,
  parent_key      TEXT,
  sort_order      INTEGER NOT NULL DEFAULT 0,

  -- Bilingual titles
  title_en        TEXT NOT NULL,
  title_es        TEXT,

  -- Bilingual content (markdown)
  content_en      TEXT NOT NULL,
  content_es      TEXT,

  -- Status & versioning
  status          TEXT NOT NULL DEFAULT 'published',
  version         INTEGER NOT NULL DEFAULT 1,

  -- FTS vectors (populated by trigger)
  search_vector_en  tsvector,
  search_vector_es  tsvector,

  -- Vector embeddings (1536d, text-embedding-3-small)
  embedding_en    vector(1536),
  embedding_es    vector(1536),

  -- Provenance
  created_by      UUID NOT NULL,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);


-- =============================================================================
-- STEP 2: CONSTRAINTS
-- =============================================================================

-- Position validation
ALTER TABLE public.steps_of_service_sections
  ADD CONSTRAINT sos_sections_position_check
  CHECK (position IN ('server', 'bartender', 'busser', 'barback'));

-- Status validation
ALTER TABLE public.steps_of_service_sections
  ADD CONSTRAINT sos_sections_status_check
  CHECK (status IN ('published', 'draft'));

-- Unique section_key per group + position
ALTER TABLE public.steps_of_service_sections
  ADD CONSTRAINT sos_sections_key_unique
  UNIQUE (group_id, position, section_key);


-- =============================================================================
-- STEP 3: INDEXES
-- =============================================================================

-- Primary query path: fetch all sections for a position in order
CREATE INDEX idx_sos_sections_group_position_sort
  ON public.steps_of_service_sections (group_id, position, sort_order)
  WHERE status = 'published';

-- English FTS
CREATE INDEX idx_sos_sections_fts_en
  ON public.steps_of_service_sections USING gin(search_vector_en);

-- Spanish FTS
CREATE INDEX idx_sos_sections_fts_es
  ON public.steps_of_service_sections USING gin(search_vector_es);

-- English vector similarity
CREATE INDEX idx_sos_sections_embedding_en
  ON public.steps_of_service_sections USING hnsw(embedding_en vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- Spanish vector similarity
CREATE INDEX idx_sos_sections_embedding_es
  ON public.steps_of_service_sections USING hnsw(embedding_es vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- Parent key lookup
CREATE INDEX idx_sos_sections_parent_key
  ON public.steps_of_service_sections (group_id, position, parent_key)
  WHERE parent_key IS NOT NULL;


-- =============================================================================
-- STEP 4: FTS TRIGGER FUNCTION + TRIGGER
-- =============================================================================

CREATE OR REPLACE FUNCTION public.update_sos_sections_search_vector()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  -- English search vector
  NEW.search_vector_en :=
    setweight(to_tsvector('english', coalesce(NEW.title_en, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(NEW.section_key, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(NEW.position, '')), 'B') ||
    setweight(to_tsvector('english', coalesce(NEW.content_en, '')), 'B');

  -- Spanish search vector (fallback to EN if ES missing)
  NEW.search_vector_es :=
    setweight(to_tsvector('spanish', coalesce(NEW.title_es, NEW.title_en, '')), 'A') ||
    setweight(to_tsvector('spanish', coalesce(NEW.section_key, '')), 'A') ||
    setweight(to_tsvector('spanish', coalesce(NEW.position, '')), 'B') ||
    setweight(to_tsvector('spanish', coalesce(NEW.content_es, NEW.content_en, '')), 'B');

  -- NULL embeddings when content changes (will be regenerated by embed function)
  IF TG_OP = 'INSERT' OR
     OLD.content_en IS DISTINCT FROM NEW.content_en OR
     OLD.content_es IS DISTINCT FROM NEW.content_es OR
     OLD.title_en IS DISTINCT FROM NEW.title_en OR
     OLD.title_es IS DISTINCT FROM NEW.title_es THEN
    NEW.embedding_en := NULL;
    NEW.embedding_es := NULL;
  END IF;

  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_sos_sections_search_vector
  BEFORE INSERT OR UPDATE ON public.steps_of_service_sections
  FOR EACH ROW EXECUTE FUNCTION public.update_sos_sections_search_vector();


-- =============================================================================
-- STEP 5: RRF HYBRID SEARCH FUNCTION
-- =============================================================================

CREATE OR REPLACE FUNCTION public.search_steps_of_service(
  search_query      TEXT,
  query_embedding   vector(1536),
  p_group_id        UUID,
  p_position        TEXT DEFAULT NULL,
  search_language   TEXT DEFAULT 'en',
  result_limit      INT DEFAULT 8,
  keyword_weight    FLOAT DEFAULT 0.4,
  vector_weight     FLOAT DEFAULT 0.6
)
RETURNS TABLE (
  id              UUID,
  section_key     TEXT,
  title           TEXT,
  snippet         TEXT,
  "position"      TEXT,
  parent_key      TEXT,
  combined_score  FLOAT
)
LANGUAGE plpgsql
STABLE SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  ts_query  tsquery;
  ts_config regconfig;
BEGIN
  IF search_language = 'es' THEN
    ts_config := 'spanish'::regconfig;
    ts_query := plainto_tsquery('spanish', search_query);
  ELSE
    ts_config := 'english'::regconfig;
    ts_query := plainto_tsquery('english', search_query);
  END IF;

  RETURN QUERY
  WITH
  kw AS (
    SELECT
      s.id,
      ROW_NUMBER() OVER (
        ORDER BY ts_rank(
          CASE WHEN search_language = 'es' THEN s.search_vector_es
               ELSE s.search_vector_en END,
          ts_query
        ) DESC
      ) AS pos
    FROM public.steps_of_service_sections s
    WHERE s.group_id = p_group_id
      AND s.status = 'published'
      AND (p_position IS NULL OR s.position = p_position)
      AND CASE WHEN search_language = 'es' THEN s.search_vector_es
               ELSE s.search_vector_en END @@ ts_query
    LIMIT result_limit * 2
  ),
  kw_stats AS (
    SELECT COUNT(*)::INT AS hit_count FROM kw
  ),
  vec AS (
    SELECT
      s.id,
      ROW_NUMBER() OVER (
        ORDER BY
          CASE WHEN search_language = 'es' AND s.embedding_es IS NOT NULL
               THEN s.embedding_es ELSE s.embedding_en END
          <=> query_embedding
      ) AS pos
    FROM public.steps_of_service_sections s
    WHERE s.group_id = p_group_id
      AND s.status = 'published'
      AND (p_position IS NULL OR s.position = p_position)
      AND CASE WHEN search_language = 'es' AND s.embedding_es IS NOT NULL
               THEN s.embedding_es ELSE s.embedding_en END IS NOT NULL
    LIMIT result_limit * 2
  ),
  combined AS (
    SELECT
      COALESCE(kw.id, vec.id) AS id,
      (CASE
        WHEN (SELECT hit_count FROM kw_stats) = 0 THEN
          COALESCE(1.0 / (60 + vec.pos), 0)
        ELSE
          keyword_weight * COALESCE(1.0 / (60 + kw.pos), 0) +
          vector_weight  * COALESCE(1.0 / (60 + vec.pos), 0)
      END)::FLOAT AS score
    FROM kw FULL OUTER JOIN vec ON kw.id = vec.id
  )
  SELECT
    c.id,
    s.section_key,
    CASE WHEN search_language = 'es' AND s.title_es IS NOT NULL
         THEN s.title_es ELSE s.title_en END,
    ts_headline(ts_config,
      COALESCE(
        CASE WHEN search_language = 'es' AND s.content_es IS NOT NULL
             THEN s.content_es ELSE s.content_en END,
        ''
      ),
      ts_query,
      'StartSel=<mark>, StopSel=</mark>, MaxWords=50, MinWords=20'
    ),
    s.position,
    s.parent_key,
    c.score
  FROM combined c
  JOIN public.steps_of_service_sections s ON s.id = c.id
  WHERE c.score > 0
  ORDER BY c.score DESC
  LIMIT result_limit;
END;
$$;


-- =============================================================================
-- STEP 6: UPDATE CHECK CONSTRAINTS ON EXISTING TABLES
-- =============================================================================

-- ai_prompts: add 'steps_of_service' to domain CHECK
ALTER TABLE public.ai_prompts
  DROP CONSTRAINT ai_prompts_domain_check;

ALTER TABLE public.ai_prompts
  ADD CONSTRAINT ai_prompts_domain_check
  CHECK (domain IS NULL OR domain IN (
    'manual', 'recipes', 'dishes', 'wines', 'cocktails', 'beer_liquor', 'steps_of_service'
  ));

-- chat_sessions: add 'steps_of_service' to context_type CHECK
ALTER TABLE public.chat_sessions
  DROP CONSTRAINT chat_sessions_context_type_check;

ALTER TABLE public.chat_sessions
  ADD CONSTRAINT chat_sessions_context_type_check
  CHECK (context_type IN (
    'manual', 'recipes', 'dishes', 'wines', 'cocktails', 'beer_liquor', 'steps_of_service'
  ));


-- =============================================================================
-- STEP 7: RLS POLICIES
-- =============================================================================

ALTER TABLE public.steps_of_service_sections ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view sos_sections"
  ON public.steps_of_service_sections FOR SELECT TO authenticated
  USING (true);

CREATE POLICY "Admins can insert sos_sections"
  ON public.steps_of_service_sections FOR INSERT TO authenticated
  WITH CHECK (has_role(auth.uid(), 'admin'::user_role));

CREATE POLICY "Admins can update sos_sections"
  ON public.steps_of_service_sections FOR UPDATE TO authenticated
  USING (has_role(auth.uid(), 'admin'::user_role))
  WITH CHECK (has_role(auth.uid(), 'admin'::user_role));

CREATE POLICY "Admins can delete sos_sections"
  ON public.steps_of_service_sections FOR DELETE TO authenticated
  USING (has_role(auth.uid(), 'admin'::user_role));
