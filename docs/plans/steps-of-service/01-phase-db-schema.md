# Phase 1: Database Schema & Migration

## Overview

Create the `steps_of_service_sections` table with all supporting objects: FTS trigger, RRF hybrid search function, CHECK constraint updates, RLS policies, and indexes. Single migration file.

---

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| Bilingual columns (`_en`/`_es`) for title, content, search_vector, embedding | Follows `manual_sections` pattern. Enables bilingual FTS + vector search. |
| Single `search_vector_en`/`search_vector_es` (not shared `search_vector`) | Content is stored per-language. FTS must match the language of the content. |
| `group_id` column (first content table with it) | SOS is designed for multi-restaurant from day 1. Each restaurant has its own SOS content. |
| `position` as TEXT with CHECK constraint | Flexible for custom positions. CHECK keeps it validated. |
| `section_key` UNIQUE per (group_id, position) not globally | Different restaurants may reuse section keys. Uniqueness is scoped. |
| `parent_key` as TEXT (not FK) | Self-referencing via key is simpler for seeds. Lookup is `WHERE section_key = parent_key AND group_id = X AND position = Y`. |
| `embedding_en`/`embedding_es` in same migration (not separate) | Avoids the split we had with manual_sections. Include vectors from the start. |
| `extensions.gen_random_uuid()` | Follows newer migration convention (schema-qualified). |

---

## Table: `steps_of_service_sections`

```sql
CREATE TABLE public.steps_of_service_sections (
  id              UUID PRIMARY KEY DEFAULT extensions.gen_random_uuid(),

  -- Multi-tenant + position scoping
  group_id        UUID NOT NULL REFERENCES public.groups(id) ON DELETE CASCADE,
  position        TEXT NOT NULL,

  -- Hierarchy
  section_key     TEXT NOT NULL,
  parent_key      TEXT,
  sort_order      INTEGER NOT NULL DEFAULT 0,

  -- Bilingual titles
  title_en        TEXT NOT NULL,
  title_es        TEXT,

  -- Bilingual content (markdown)
  content_en      TEXT NOT NULL,
  content_es      TEXT,

  -- Status & versioning
  status          TEXT NOT NULL DEFAULT 'published',
  version         INTEGER NOT NULL DEFAULT 1,

  -- FTS vectors (populated by trigger)
  search_vector_en  tsvector,
  search_vector_es  tsvector,

  -- Vector embeddings (1536d, text-embedding-3-small)
  embedding_en    vector(1536),
  embedding_es    vector(1536),

  -- Provenance
  created_by      UUID NOT NULL,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

### Column Notes

| Column | Type | Nullable | Purpose |
|--------|------|----------|---------|
| `group_id` | UUID FK → groups | NOT NULL | Multi-tenant isolation |
| `position` | TEXT | NOT NULL | `server`, `bartender`, `busser`, `barback` |
| `section_key` | TEXT | NOT NULL | Slug-like key: `first-approach`, `warm-welcome` |
| `parent_key` | TEXT | NULL | Points to parent section's `section_key` (same group+position) |
| `sort_order` | INTEGER | NOT NULL | Display order within position (or within parent) |
| `title_en` | TEXT | NOT NULL | English section title |
| `title_es` | TEXT | NULL | Spanish section title (optional, falls back to EN) |
| `content_en` | TEXT | NOT NULL | English markdown content |
| `content_es` | TEXT | NULL | Spanish markdown content |
| `status` | TEXT | NOT NULL | `published` / `draft` |
| `version` | INTEGER | NOT NULL | Content version tracking |
| `search_vector_en` | tsvector | NULL | Auto-populated by trigger |
| `search_vector_es` | tsvector | NULL | Auto-populated by trigger |
| `embedding_en` | vector(1536) | NULL | Generated by embed function |
| `embedding_es` | vector(1536) | NULL | Generated by embed function |
| `created_by` | UUID | NOT NULL | Admin user who created the row |

---

## Constraints

```sql
-- Position validation
ALTER TABLE public.steps_of_service_sections
  ADD CONSTRAINT sos_sections_position_check
  CHECK (position IN ('server', 'bartender', 'busser', 'barback'));

-- Status validation
ALTER TABLE public.steps_of_service_sections
  ADD CONSTRAINT sos_sections_status_check
  CHECK (status IN ('published', 'draft'));

-- Unique section_key per group+position
ALTER TABLE public.steps_of_service_sections
  ADD CONSTRAINT sos_sections_key_unique
  UNIQUE (group_id, position, section_key);
```

### CHECK Constraint Updates (existing tables)

```sql
-- ai_prompts: add 'steps_of_service' to domain CHECK
ALTER TABLE public.ai_prompts
  DROP CONSTRAINT ai_prompts_domain_check;

ALTER TABLE public.ai_prompts
  ADD CONSTRAINT ai_prompts_domain_check
  CHECK (domain IS NULL OR domain IN (
    'manual', 'recipes', 'dishes', 'wines', 'cocktails', 'beer_liquor', 'steps_of_service'
  ));

-- chat_sessions: add 'steps_of_service' to context_type CHECK
ALTER TABLE public.chat_sessions
  DROP CONSTRAINT chat_sessions_context_type_check;

ALTER TABLE public.chat_sessions
  ADD CONSTRAINT chat_sessions_context_type_check
  CHECK (context_type IN (
    'manual', 'recipes', 'dishes', 'wines', 'cocktails', 'beer_liquor', 'steps_of_service'
  ));
```

---

## Indexes (6 total)

```sql
-- 1. Composite: primary query path (fetch all sections for a position in order)
CREATE INDEX idx_sos_sections_group_position_sort
  ON public.steps_of_service_sections (group_id, position, sort_order)
  WHERE status = 'published';

-- 2. GIN: English FTS
CREATE INDEX idx_sos_sections_fts_en
  ON public.steps_of_service_sections USING gin(search_vector_en);

-- 3. GIN: Spanish FTS
CREATE INDEX idx_sos_sections_fts_es
  ON public.steps_of_service_sections USING gin(search_vector_es);

-- 4. HNSW: English vector similarity
CREATE INDEX idx_sos_sections_embedding_en
  ON public.steps_of_service_sections USING hnsw(embedding_en vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- 5. HNSW: Spanish vector similarity
CREATE INDEX idx_sos_sections_embedding_es
  ON public.steps_of_service_sections USING hnsw(embedding_es vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- 6. Lookup: parent_key resolution
CREATE INDEX idx_sos_sections_parent_key
  ON public.steps_of_service_sections (group_id, position, parent_key)
  WHERE parent_key IS NOT NULL;
```

---

## FTS Trigger Function

Follows `manual_sections` bilingual pattern (dual vectors, language-specific configs, embedding invalidation on content change).

```sql
CREATE OR REPLACE FUNCTION public.update_sos_sections_search_vector()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  -- English search vector
  NEW.search_vector_en :=
    setweight(to_tsvector('english', coalesce(NEW.title_en, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(NEW.section_key, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(NEW.position, '')), 'B') ||
    setweight(to_tsvector('english', coalesce(NEW.content_en, '')), 'B');

  -- Spanish search vector (fallback to EN)
  NEW.search_vector_es :=
    setweight(to_tsvector('spanish', coalesce(NEW.title_es, NEW.title_en, '')), 'A') ||
    setweight(to_tsvector('spanish', coalesce(NEW.section_key, '')), 'A') ||
    setweight(to_tsvector('spanish', coalesce(NEW.position, '')), 'B') ||
    setweight(to_tsvector('spanish', coalesce(NEW.content_es, NEW.content_en, '')), 'B');

  -- NULL embeddings when content changes (will be regenerated)
  IF TG_OP = 'INSERT' OR
     OLD.content_en IS DISTINCT FROM NEW.content_en OR
     OLD.content_es IS DISTINCT FROM NEW.content_es OR
     OLD.title_en IS DISTINCT FROM NEW.title_en OR
     OLD.title_es IS DISTINCT FROM NEW.title_es THEN
    NEW.embedding_en := NULL;
    NEW.embedding_es := NULL;
  END IF;

  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_sos_sections_search_vector
  BEFORE INSERT OR UPDATE ON public.steps_of_service_sections
  FOR EACH ROW EXECUTE FUNCTION public.update_sos_sections_search_vector();
```

### Weight Rationale

| Weight | Fields | Why |
|--------|--------|-----|
| A (highest) | `title_en`, `section_key` | Direct matches on section name/key are most relevant |
| B | `position`, `content_en/es` | Position matches and content body are important but broader |

---

## RRF Hybrid Search Function

Follows the `search_dishes` pattern with adaptive weighting, plus `manual_sections` bilingual support. Adds `group_id` (required) and `position` (optional) filters.

```sql
CREATE OR REPLACE FUNCTION public.search_steps_of_service(
  search_query      TEXT,
  query_embedding   vector(1536),
  p_group_id        UUID,
  p_position        TEXT DEFAULT NULL,
  search_language   TEXT DEFAULT 'en',
  result_limit      INT DEFAULT 8,
  keyword_weight    FLOAT DEFAULT 0.4,
  vector_weight     FLOAT DEFAULT 0.6
)
RETURNS TABLE (
  id              UUID,
  section_key     TEXT,
  title           TEXT,
  snippet         TEXT,
  position        TEXT,
  parent_key      TEXT,
  combined_score  FLOAT
)
LANGUAGE plpgsql
STABLE SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  ts_query  tsquery;
  ts_config regconfig;
BEGIN
  IF search_language = 'es' THEN
    ts_config := 'spanish'::regconfig;
    ts_query := plainto_tsquery('spanish', search_query);
  ELSE
    ts_config := 'english'::regconfig;
    ts_query := plainto_tsquery('english', search_query);
  END IF;

  RETURN QUERY
  WITH
  kw AS (
    SELECT
      s.id,
      ROW_NUMBER() OVER (
        ORDER BY ts_rank(
          CASE WHEN search_language = 'es' THEN s.search_vector_es
               ELSE s.search_vector_en END,
          ts_query
        ) DESC
      ) AS pos
    FROM public.steps_of_service_sections s
    WHERE s.group_id = p_group_id
      AND s.status = 'published'
      AND (p_position IS NULL OR s.position = p_position)
      AND CASE WHEN search_language = 'es' THEN s.search_vector_es
               ELSE s.search_vector_en END @@ ts_query
    LIMIT result_limit * 2
  ),
  kw_stats AS (
    SELECT COUNT(*)::INT AS hit_count FROM kw
  ),
  vec AS (
    SELECT
      s.id,
      ROW_NUMBER() OVER (
        ORDER BY
          CASE WHEN search_language = 'es' AND s.embedding_es IS NOT NULL
               THEN s.embedding_es ELSE s.embedding_en END
          <=> query_embedding
      ) AS pos
    FROM public.steps_of_service_sections s
    WHERE s.group_id = p_group_id
      AND s.status = 'published'
      AND (p_position IS NULL OR s.position = p_position)
      AND CASE WHEN search_language = 'es' AND s.embedding_es IS NOT NULL
               THEN s.embedding_es ELSE s.embedding_en END IS NOT NULL
    LIMIT result_limit * 2
  ),
  combined AS (
    SELECT
      COALESCE(kw.id, vec.id) AS id,
      (CASE
        WHEN (SELECT hit_count FROM kw_stats) = 0 THEN
          COALESCE(1.0 / (60 + vec.pos), 0)
        ELSE
          keyword_weight * COALESCE(1.0 / (60 + kw.pos), 0) +
          vector_weight  * COALESCE(1.0 / (60 + vec.pos), 0)
      END)::FLOAT AS score
    FROM kw FULL OUTER JOIN vec ON kw.id = vec.id
  )
  SELECT
    c.id,
    s.section_key,
    CASE WHEN search_language = 'es' AND s.title_es IS NOT NULL
         THEN s.title_es ELSE s.title_en END,
    ts_headline(ts_config,
      COALESCE(
        CASE WHEN search_language = 'es' AND s.content_es IS NOT NULL
             THEN s.content_es ELSE s.content_en END,
        ''
      ),
      ts_query,
      'StartSel=<mark>, StopSel=</mark>, MaxWords=50, MinWords=20'
    ),
    s.position,
    s.parent_key,
    c.score
  FROM combined c
  JOIN public.steps_of_service_sections s ON s.id = c.id
  WHERE c.score > 0
  ORDER BY c.score DESC
  LIMIT result_limit;
END;
$$;
```

### Search Function Differences from Product Functions

| Aspect | Product (`search_dishes`) | SOS (`search_steps_of_service`) |
|--------|--------------------------|-------------------------------|
| Language support | English only | Bilingual (EN/ES) — follows `hybrid_search_manual` |
| Group filtering | None | `p_group_id` required |
| Position filtering | N/A | `p_position` optional |
| Snippet source | `short_description + detailed_description` | `content_en` or `content_es` |
| Adaptive weighting | Yes (100% vector if FTS=0) | Yes (same pattern) |

---

## RLS Policies (4)

Same pattern as all product tables: any authenticated user can SELECT, admin-only for write operations.

```sql
ALTER TABLE public.steps_of_service_sections ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view sos_sections"
  ON public.steps_of_service_sections FOR SELECT TO authenticated
  USING (true);

CREATE POLICY "Admins can insert sos_sections"
  ON public.steps_of_service_sections FOR INSERT TO authenticated
  WITH CHECK (has_role(auth.uid(), 'admin'::user_role));

CREATE POLICY "Admins can update sos_sections"
  ON public.steps_of_service_sections FOR UPDATE TO authenticated
  USING (has_role(auth.uid(), 'admin'::user_role))
  WITH CHECK (has_role(auth.uid(), 'admin'::user_role));

CREATE POLICY "Admins can delete sos_sections"
  ON public.steps_of_service_sections FOR DELETE TO authenticated
  USING (has_role(auth.uid(), 'admin'::user_role));
```

> **Note**: RLS uses `USING (true)` for SELECT (same as product tables), not group-scoped. Group filtering happens in the application layer (queries) and search function (required `p_group_id`). This avoids the complexity of RLS-level group membership checks while still ensuring queries are scoped.

---

## Migration File Structure

Single file: `supabase/migrations/TIMESTAMP_create_steps_of_service_sections.sql`

### Execution Order

1. Create table
2. Add constraints (position CHECK, status CHECK, unique composite)
3. Create indexes (6)
4. Create trigger function + trigger
5. Create search function
6. Update `ai_prompts.domain` CHECK constraint
7. Update `chat_sessions.context_type` CHECK constraint
8. Enable RLS + create 4 policies

---

## Verification Checklist

After pushing the migration:

- [ ] Table exists: `SELECT count(*) FROM steps_of_service_sections;` → 0
- [ ] Constraints: `\d+ steps_of_service_sections` shows all CHECK constraints
- [ ] Indexes: 6 indexes visible (composite, 2× GIN, 2× HNSW, parent_key)
- [ ] Trigger: Insert a test row → `search_vector_en` auto-populated
- [ ] Search function: `SELECT * FROM search_steps_of_service('test', ..., group_id);` → runs without error (empty result OK)
- [ ] ai_prompts: `INSERT INTO ai_prompts (slug, category, domain, ...) VALUES ('test-sos', 'action', 'steps_of_service', ...);` → succeeds
- [ ] chat_sessions: Can create session with `context_type = 'steps_of_service'`
- [ ] RLS: Authenticated user can SELECT; non-admin cannot INSERT
- [ ] Security advisor: Run `get_advisors(type: 'security')` — no new warnings

---

## Dependencies

- **Requires**: pgvector extension (already enabled)
- **Requires**: `public.groups` table (exists)
- **Requires**: `has_role()` function (exists)
- **Requires**: `public.update_updated_at_column()` function (exists — but NOT used here since the trigger does `NEW.updated_at := now()` inline)
- **Blocks**: Phase 2 (content seed)
- **Blocks**: Phase 5 (embeddings)
